
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`timescale 1 ns/10 ps  // time-unit = 1 ns, precision = 10 ps

module DE1_SOC_D8M_LB_RTL_tb;

//=============================================================================
// REG/WIRE declarations
//=============================================================================
	//////////// CLOCK //////////
	reg 		          		clock;

	//////////// KEY //////////
	reg 		     [3:0]		KEY;

	//////////// LED //////////
	reg		     [9:0]		LEDR;

	//////////// SW //////////
	reg 		     [9:0]		SW;

	
   reg 	[7:0]raw_VGA_R;
   reg 	[7:0]raw_VGA_G;
   reg 	 [7:0]raw_VGA_B;
 
   reg  [12:0]x_count,col; 
   reg  [12:0]y_count,row; 
   
//=======================================================
// Structural coding
//=======================================================
 

// OUR CODE
wire [7:0] VGA_R_OUT, VGA_G_OUT, VGA_B_OUT;
wire [7:0] br_out_r, br_out_g, br_out_b, clr_dtc_r, clr_dtc_g, clr_dtc_b,
				grn_r, grn_g, grn_b, gry_r, gry_g, gry_b;
wire binc, bdec, cinc, cdec;
reg [31:0] enable;
reg reset;

reg frame_en;
reg [3:0] clr_sel;
colordetc cdet(.clr_sel(clr_sel),.clk(clock), .rst(SW[0]), .in_r(raw_VGA_R), .in_g(raw_VGA_G), .in_b(raw_VGA_B), 
					.out_r(clr_dtc_r), .out_g(clr_dtc_g), .out_b(clr_dtc_b), .ctrl_out());
					
greensc gsc(.in_r(clr_dtc_r), .in_b(clr_dtc_g), .in_g(clr_dtc_b), .gsc_en(enable[4]), .gsc_out_r(grn_r), .gsc_out_g(grn_g),
				.gsc_out_b(grn_b));

grayscale gryscale(.clk(clock), .rst(SW[0]), .enable(enable[3]), .frame_en(frame_en), .in_R(grn_r), .in_G(grn_g), 
						.in_B(grn_b), .out_R(gry_r), .out_G(gry_g), .out_B(gry_b));
									
brightness br(.clk(clock), .enable(enable[0]), .frame_en(frame_en), .rst(SW[0]), .inc(binc), .dec(bdec),
					.R(gry_r), .G(gry_g), .B(gry_b), .outR(br_out_r), .outG(br_out_g), .outB(br_out_b));
					
contrast crst(.clk(clock), .enable(enable[0]), .frame_en(frame_en), .rst(SW[0]), .inc(cinc), .dec(cdec),
					.R(br_out_r), .G(br_out_g), .B(br_out_b), .outR(VGA_R_OUT), .outG(VGA_G_OUT), .outB(VGA_B_OUT));

control ctrl(.clk(clock), .en(), .row(row), .col(col), .x_count(x_count), .y_count(y_count),.rst(SW[0])
					, .binc(binc), .bdec(bdec), .cinc(cinc), .cdec(cdec), 
					.clr_sel(),.SW(SW), .KEY(KEY), .frame_en()); // frame_en is never true
	initial begin
		enable = 1'b0;
		frame_en = 1'b0;
		#100; // perhaps a few cycles
		#100;
		raw_VGA_R = 8'hDC;
		raw_VGA_G= 8'hCD;
		raw_VGA_B = 8'hEE;
		col = 0;
		row = 0;
		enable = 1'b1;
		SW = 10'b00000_00010;
		#100;
		#100;
		$finish; // stop simulation
	end
	always begin
		if (reset == 1'b1) begin
			clock = 1'b0;
			#10; // let time advance when reset == 1'b1
			end
		else begin
			#100; // cycle time = #200
			clock = ~clock; // invert clock
		end
	end

endmodule
